
<!doctype html> 
<html> 
<head> 
<title>Документация по системе doit cms</title> 
<style> 
html
{
	background:#eeeeee;
		margin-top:0;
	padding-top:0;
}
	body
	{
	background:white;
 
	padding:30px;
	margin-top:0;
		width:800px;
		margin:auto;
	
		color: black;
		font-family: Palatino, "Palatino Linotype", "URW Palladio L", "Book Antiqua", Georgia, serif;
		line-height: 1.45;
	}
</style> 
</head> 
<body> 
	<h1>О системе DoIt CMS</h1> 
 
<h2>Общие принципы</h2> 
 
<h3>Принцип упрощения работы приложения</h3> 
 
<p>Похожие сущности, малое количество IF, разные формы одно и тоже, малое количество тегов и
правил</p> 
 
<h3>MVC</h3> 
 
<p>Используются основные принципы MVC (разделение логики, данных, и функций, их
соединяющих). Реализация отличается от классического подхода.</p> 
 
<p><strong>Модель</strong> – это класс, который необязательно объявлять, но его экземпляры можно
использовать. Он позволяет обращаться к базе данных как к объектам.</p> 
 
<p><strong>Контроллер</strong> – это множество функций, переопределяемых при помощи правил роутера. Также
это помощники (helpers , фрагменты разметки, содержащих код), обработчики для форм
(<code>action('client#update')</code>), альтернативные валидаторы, функции для отправки электронной
почты и т.д.</p> 
 
<p><strong>Вид</strong> – это множество функций, объявляемых автоматически на основе файлов с разметкой,
переопределяемых при помощи правил роутера. Может содержать PHP-код, например, для
сложных проверок. Каждая такая функция возвращает готовый HTML-код. Например <code>print d()-&gt;about();</code> 
выведет шаблон about.html.</p> 
 
<p>Также есть несколько дополнительных сущностей:</p> 
 
<p><strong>Опции</strong> – .ini файлы, которые инициализируют переменные (свойства) основного объекта.
Они же определяют правила роутера, списки полей для системы администрирования, опции
сайта в целом, логин и пароль администратора, правила для валидации форм. При помощи
опций можно переопределить любую функцию или шаблон, или заставить выполниться
дополнительную функцию или дополнительный шаблон, объявить переменную или массив.</p> 
 
<p><strong>Обработчики форм</strong> – часть контроллера, принимают, проверяют и обрабатывают POST
запросы.</p> 
 
<p><strong>Помощники (Helpers)</strong> – функции, результат работы которых используется для генерации HTML
кода (формы, поля редактирования, ссылки, метатеги и так далее). Часть контроллера, в
большинстве своём независимые и не привязаны к какому-то определённому контроллеру.</p> 
 
<h3>Отличия от большинства MVC фреймворков</h3> 
 
<p>В отличие от большинства MVC фреймворков, данный фреймворк не следует принципу «ООП
ради ООП», не является строго ООП-фреймворком, старается не плодить различные сущности,
а объединять похожие сущности едиными правилами для упрощения схемы работы и
понимания, ставит скорость разработки, поддержки, лаконичность кода, единые принципы и
гибкость выше, чем соблюдение общепринятых принципов MVC .</p> 
 
<p>В отличие от большинства MVC фреймворков, модель не содержит общего кода (например,
отправка электронной почты), и вся логика содержится в контроллере (антипаттерн Fat
Controller или FSUC). Более того, во многих проектах объявление модели может вовсе
отсутствовать.</p> 
 
<p>В отличие от большинства MVC фреймворков, в некоторых случаях допустимо обращаться к
Модели из Вида, минуя контроллер, если это упростит код, его написание или поддержку.
Например:</p> 
 
<pre><code>&lt;ul&gt;
    &lt;foreach User-&gt;all as user&gt;
        &lt;li&gt;{user.login}&lt;/li&gt;
    &lt;/foreach&gt;
&lt;/ul&gt;
</code></pre> 
 
<p>Здесь выводятся все записи из таблицы users. Примечание: данный пример усложняет в
дальнейшем работу с кодом (например, добавление фильтраций или сортировки,
переопределение и т.д.). Поэтому всё-таки лучше выводить подобный код в контроллер.</p> 
 
<p>В отличие от большинства MVC фреймворков, контроллер отдельной сущности может быть как
функцией, так и классом с набором методов, так и смесью двух подходов. Более того,
возможна разработка приложения без единого дополнительного класса (как контроллера, так
и модели или иных сущностей) без потери каких-либо возможностей.</p> 
 
<p>В отличие от большинства MVC фреймворков, допустимо использование методов контроллера
напрямую в Виде (при помощи спец. тега), и вызов шаблонов Вида из Контроллера для
дальнейшей обработки (например, замене спец. символов).</p> 
 
<p>В отличие от большинства MVC фреймворков, валидацию проводит не модель, а контроллер. 
Так как модель в контексте данной системы это прослойка для работы с базой данных, то она
не может взять на себя валидацию таких сущностей, как формы обратной связи, формы
фильтрации вывода или формы поиска данных, формы авторизации и выхода из системы,
формы калькуляторов и формы смены опций, т.к. все эти примеры не воздействуют на базу
данных, однако необходимы в реальных приложениях. Если бы валидацию проводила модель
при попытке сохранить данные (например, при редактировании статьи), а валидацию
правильной сортировки и формы отправки сообщения —контроллер, то существовали бы две
различные реализации валидатора, что противоречит принципу упрощения схемы работы
приложения.</p> 
 
<p>В отличие от большинства MVC фреймворков, модель не хранит состояние приложения между
запросами в классическом понимании — модель не отвечает за хранение сессий и cookies.
Однако модель хранит состояние приложения в базе данных.</p> 
 
<p>В отличие от большинства MVC фреймворков, реализация модели близка к классическим CMS,
и использует только MySQL базу данных и не имеет абстракций для работы с другими СУБД
или иными источниками данных.</p> 
 
<p>В отличие от большинства MVC фреймворков, роутер способен влиять на Вид, а также
переопределять дополнительные функции-помощники (например, {{form}} или {{input}})</p> 
 
<p>В отличие от большинства MVC фреймворков, каждый URL не имеет привязанного роутером
контроллера. На одной странице может существовать несколько сущностей, гибко
контролируемым независимо по правилам URL и разными контроллерами. Т.н. классические
«виджеты» (например, форма отправки почтового сообщения или форма авторизации)
работают по тем же принципам, что и основной контент, вызываются одинаково, также могут
быть переопределены по правилам роутера и представляют собой одно и то же, в
соответствии с принципом упрощения схемы работы приложения. Тоже самое касается
фрагментов HTML-вёрстки (например, {{footer}}).</p> 
 
<p>В отличие от большинства MVC фреймворков, layout (разметка всей страницы) и view
(разметка контента страницы) — одна и та же сущность, в соответствии с принципом
упрощения схемы работы приложения. Более того, даже обычные функции — это та же самая
сущность, что и вышеуказанные, и могут вызываться напрямую из вида либо вообще отвечать
за общий layout. Например, если существует функция summa() { return 2+2; }, то следующее
правило в роутере: <code>/mypage main summa</code> заставит по адресу http://сайт/mypage вывести число 4 вместо HTML кода разметки.</p> 
 
<h2>Переменные и функции</h2> 
 
<p>TODO: описать следующее</p> 
 
<ul> 
<li>d()->var</li> 
<li>d()->user_controller->func()</li> 
<li>d('var')</li> 
<li>{var}</li> 
<li>{var.title}</li> 
<li>{var.title|h}</li> 
<li>{{func}}</li> 
<li>{{admin#script}}</li> 
<li>{{helper "mail"}}</li> 
<li>{{helper "style"=>"color:red;"}}</li> 
<li>main, content</li> 
<li>Принцип переопределения</li> 
<li>Схема работы приложения</li> 
</ul> 
 
<h2>Фрагменты</h2> 
 
<h3>Объявление фрагмента</h3> 
 
<p>Для объявления фрагмента с именем fragmentname необходимо создать файл
fragmentname.html в директории app.</p> 
 
<p>Также можно объявить функцию (например, в файле filename.func.php в директории app),
которая будет возвращать вывод фрагмента.</p> 
 
<h3>Поиск фрагмента</h3> 
 
<p>Механизм поиска нужного фрагмента для запуска довольно нетривиален.</p> 
 
<ol> 
<li>При попытке запуска функции ищется сама функция с этим именем.</li> 
<li>Если такая функция отсутствует, то выполняется функция, оканчивающая на _tpl.</li> 
<li>Если существует файл main.html, то объявится функция main_tpl().</li> 
</ol> 
 
<p>Таким образом, для вставки фрагмента шаблона с именем footer, необходимо создать файл
footer.html и вызвать <code>{{footer}}</code> там, где надо. Это сработает только в том случае, если функция
footer() отсутствует (правило 2). Также можно использовать <code>{{footer_tpl}}</code>. Также можно создать
файл footer.tpl.html, результат будет абсолютно тем же. Префикс .tpl всегда можно опускать.</p> 
 
<p>Если необходимо использовать обычную функцию, просто объявляется функция.</p> 
 
<p>Если необходимо использовать пару функция/функция-шаблон, то объявляется функция
<code>clients_show()</code>, и шаблон clients_show.html
Для вызова первой используется <code>clients_show()</code>, для второй <code>clients_show_tpl()</code>.</p> 
 
<p>(не реализовано) При вызове обычной функции, если шаблон существует, то он будет
присоединён в цепочке к существующей по умолчанию.</p> 
 
<p>Например, <code>d()-&gt;main()</code> при отсутствии функции <code>main()</code> выполнит <code>d()-&gt;main_tpl();</code></p> 
 
<p>Однако, если существует файл main.tpl.html, то объявится функция <code>main_tpl()</code>.</p> 
 
<p>Фрагмент по сути есть метод основного объекта системы, который возвращает HTML код либо
промежуточные данные. При наличии файла fragmentname.html такая функция объявится
автоматически.</p> 
 
<p>Имя фрагмента может содержать латинские буквы, цифры и знак подчёркивания (как и
названия функций).</p> 
 
<h2>Цепочки вызовов</h2> 
 
<p>Допустим, в роутере указана следующая строка</p> 
 
<pre><code>/ content default default_tpl
</code></pre> 
 
<p>Это означает, что на страницах, начинащихся с / (всех) при вызове функции content выполнится
<code>d()-&gt;default()</code>, а затем <code>d()-&gt;default_tpl()</code>. В первом файле может проводиться инициализация, а
во втором - вывод.
Можно вызвать безымянную цепочку напрямую: </p> 
 
<pre><code>d()-&gt;call('default', 'default_tpl');
</code></pre> 
 
<p>Каждый
элемент из цепочки не будет переопределён по правилам переопределения.</p> 
 
<h3><code>set_next_chain</code></h3> 
 
<p><code>d()-&gt;set_next_chain('название_функции')</code> 
Переопределяет следующий элемент в цепочке
вызовов, определённой в роутере. Она переопределяет следующий элемент в очереди, или
добавляет новый, если такого элемента нет.</p> 
 
<p>например, <code>d()-&gt;set_next_chain('fosv')</code> вызовет <code>d()-&gt;fosv()</code> сразу после окончания работы текущей
функции. Её вывод присоединится к выводу текущей функции.</p> 
 
<h3><code>stop_next_chains</code></h3> 
 
<p><code>d()-&gt;stop_next_chains()</code> отменит все следующие функции в цепочке.</p> 
 
<h2>Вызов врагментов</h2> 
 
<p>Для вызова фрагмента и получения его вывода необходимо вызвать <code>doit()-&gt;fragmentname();</code> 
Соответственно, для вывода <code>&lt;?php print doit()-&gt;fragmentname(); ?&gt;</code></p> 
 
<p>Внутри шаблонов можно использовать <code>&lt;?php print $this-&gt;fragmentname(); ?&gt;</code>. Все функции
фрагментов не выводят данные, а только возвращают, это означает, что полученные данные
всегда можно дополнительно обработать.</p> 
 
<p>В контексте шаблона можно использовать короткую запись <code>{{fragmentname}}</code>.</p> 
 
<p>В процессе работы сайта, как правило, первым вызывается фрагмент <code>main()</code>, который вызывает
остальные (например, content для основного содержимого страницы). На комбинации
фрагментов и стоится сайт, с учётом того, что фрагменты могут быть переопределены с учётом
текущего URL (например, переопределён основной макет, середина страницы, заголовок
(header.html), функция получения списка с данными и иные функции по желанию
разработчика).</p> 
 
<p>Если фрагмент или функция вернули <code>return "текст"</code>, то вывод переопределится эти текстом.</p> 
 
<h2>ini-файлы и их применения</h2> 
 
<p>ini - файлы применяются для следующих случаев:</p> 
 
<ul> 
<li>роутеры адресов</li> 
<li>предварительные и последующие вызовы функций</li> 
<li>поля и их типы для редактирования</li> 
<li>опции сайта в целом (адреса электронной почты)</li> 
<li>логины и пароли администраторов</li> 
<li>такие вещи, как текущий город или страна (для мультирегиональных сайтов)</li> 
<li>названия и типы полей для редактирования в системе администрирования</li> 
<li>пути к различным файлам, опции для подключения к базам данных</li> 
</ul> 
 
<h2>Стандартные функции</h2> 
 
<h3><code>url</code></h3> 
 
<p>Функция url позволяет узнать, какие параметры есть в адресе текущей страницы</p> 
 
<p>Пример использования:</p> 
 
<p>Допустим, URL страницы /users/ainu/comments/13/14/52/page/4/edit?yes=no</p> 
 
<pre><code>print url() // users/ainu/comments/13/14/52/page/4/edit
print url(1) // users
print url(2) // ainu
print url('users') // ainu
print url('page') // 4
print url('comments',3) // 13/14/52
print url('comments',-2) // 13/14/52/page
</code></pre> 
 
<h2>Формы, валидаторы и действия (action)</h2> 
 
<p>TODO:</p> 
 
<pre><code>{{form}}
[validator.mail.title]
d()-&gt;action('form#send');
</code></pre> 
 
<p>Два типа действий - с перезагрузкой и действием</p> 
 
<h2>Модуль Active Record (mod_orm)</h2> 
 
<p>mod_orm добавляет поддержку объекта Active Record для упрощения SQL-запросов.</p> 
 
<p>Если функция не имеет параметров, то её можно вызывать в качестве переменной, просто
опустив скобки (в большинстве случаев также доступен классический подход), например</p> 
 
<pre><code>d()-&gt;User-&gt;all
d()-&gt;User-&gt;one
d()-&gt;User-&gt;expand_to_client
</code></pre> 
 
<h3>Объявление</h3> 
 
<p>Для указания того, какой таблице соответствует объект, ничего не нужно. Объявлять класс для
каждого отдельного типа объекта тоже не обязательно.</p> 
 
<p>Для поиска по таблице users используется запись <code>d()-&gt;Users;</code></p> 
 
<p>Например:</p> 
 
<pre><code>d()-&gt;User-&gt;find(2)-&gt;title;
</code></pre> 
 
<p>Для поиска по любой другой таблице используется имя объекта, начинаемое с заглавной
буквы, и представляющее собой название таблицы в единственном числе по правилам
английской грамматики.</p> 
 
<p>Например, <code>d()-&gt;Category</code> ищет по таблице categories, а <code>d()-&gt;News</code> ищет по таблице news</p> 
 
<p>Альтернативная запись <code>d('User')</code> (Примечание: такая запись подходит для запроса любого
свойства основного объекта, например, <code>d('title')</code>).</p> 
 
<p>Для дальнейшего использования можно передавать вызовы по цепочке или используя
промежуточный объект:</p> 
 
<pre><code>print d()-&gt;User-&gt;find(2)-&gt;title;
</code></pre> 
 
<p>равнозначно</p> 
 
<pre><code>$user= d()-&gt;User;
$user=$user-&gt;find(2);
print $user-&gt;title;
</code></pre> 
 
<p>либо равнозначно</p> 
 
<pre><code>$user2= d()-&gt;User;
$user2-&gt;find(2);
print $user2-&gt;login;
</code></pre> 
 
<p>Также разрешён альтернативный подход</p> 
 
<pre><code>$user2= new User();
$user2-&gt;find(2);
print $user2-&gt;login;
</code></pre> 
 
<p>Также разрешается объявлять класс самому, наследуя его от класса ar</p> 
 
<p>В этом случае имеется возможность использовать свои методы класса и переопределять
существующие.</p> 
 
<h3><code>find()</code></h3> 
 
<p>Осуществляет поиск по id</p> 
 
<pre><code>d()-&gt;User-&gt;find(34);
</code></pre> 
 
<p>Непосредственно запрос выполнится перед получением данных (ленивый запрос).</p> 
 
<p>Отменяет действие выполненных ранее функций <code>find()</code>, <code>find_by_*()</code>, <code>where()</code></p> 
 
<h3><code>find_by_&lt;field&gt;</code></h3> 
 
<p>Ищет по определённому полю и автоматически экранирует запрос для предотвращения SQL-
инъекций. Например:</p> 
 
<pre><code>d()-&gt;User-&gt;find_by_login('ainu')    // ищет по полю login
d()-&gt;User-&gt;find_by_username('ainu') // ищет по полю username
</code></pre> 
 
<p>Отменяет действие выполненных ранее функций <code>find()</code>, <code>find_by_*()</code>, <code>where()</code></p> 
 
<h3><code>where()</code></h3> 
 
<p>where задаёт условия для будущего запроса и автоматически экранирует запрос для
предотвращения SQL-инъекций. Отменяет действие выполненных ранее функций <code>find()</code>,
<code>find_by_*()</code>, <code>where()</code></p> 
 
<p>Например:</p> 
 
<pre><code>d('User')-&gt;where('login = ? and password=?', $username, md5($password));
d('User')-&gt;where('login LIKE ?', '%строка%');
</code></pre> 
 
<h3><code>all</code></h3> 
 
<p>Выполняет SQL-запрос (если не выполнен) и возвращает массив всех данных (в виде массива
объектов ActiveRecord).</p> 
 
<pre><code>$goods = d()-&gt;Good-&gt;find_by_color('red')-&gt;all;
print $goods[0]-&gt;title;
</code></pre> 
 
<h3>one</h3> 
 
<p>Выполняет SQL-запрос (если не выполнен) и возвращает один объект (первый) в виде
ассоциативного массива поле=>значение.</p> 
 
<pre><code>$maika = d()-&gt;Good-&gt;find(12)-&gt;one;
</code></pre> 
 
<h3><code>is_empty</code></h3> 
 
<p>Немедленно выполняет SQL - запрос (до попытки получения первого свойства), и возвращает
true, если получено 0 элементов.</p> 
 
<h3><code>expand</code> и <code>expand_to</code></h3> 
 
<p>Функции копируют данные из ActiveRecord объекта в глобальную область объектов для
использования в шаблонах</p> 
 
<pre><code>d('Text')-&gt;find_by_url(url(1))-&gt;expand_to_page;
</code></pre> 
 
<p>После этого в шаблоне можно указывать <code>{page.title}</code></p> 
 
<pre><code>d()-&gt;Client-&gt;find_by_name('Керхер')-&gt;expand_to_client;
</code></pre> 
 
<p>После этого в шаблоне можно указывать <code>{client.title}</code></p> 
 
<pre><code>d()-&gt;Client-&gt;find(374)-&gt;expand;
</code></pre> 
 
<p>После этого в шаблоне можно указывать <code>{title}</code></p> 
 
<p>Примечание: от функции expand можно отказаться классическим методом:</p> 
 
<pre><code>d()-&gt;page = d('Text')-&gt;find_by_url(url(1));
</code></pre> 
 
<p>После этого в шаблоне можно указывать <code>{page.title}</code></p> 
 
<p>Возвращает <code>false</code>, если подходящих строк не было найдено.</p> 
 
<h3><code>new</code>, <code>save</code> и <code>delete</code></h3> 
 
<p><code>save</code> и <code>delete</code> завершают предыдущие операции, используются для установки флага
дальнейшего создания строки в базе данных, сохранения данных и удаления строки.</p> 
 
<p><code>delete</code> - удаляет последний найденный через find элемент, если элементы искались через
where, то удаляется первый. Фактически, при <code>$var-&gt;delete;</code> удаляется элемент с id, равным <code>$var-&gt;id</code>.</p> 
 
<p>Если такой строки нет, ничего не произойдёт.</p> 
 
<p><code>save</code> - сохраняет изменения. Функция new не совершает никаких действий с базой данных,
только указывает на необходимость создания новой строки в базе данных. Если до save было
сделано $var->new, то при сохранении создастся новая строка, иначе изменится последняя
найденная через find или where строка. Если при попытке сохранения для изменений после
поиска строк было несколько, то изменится первая. Фактически, при $var->save; меняется
элемент с <code>id</code> = $var->id. Если такой строки нет, ничего не произойдёт.</p> 
 
<p>Для задания поля необходимо присвоить значение соответствующей переменной. Например,</p> 
 
<pre><code>$var-&gt;title='Заголовок';
</code></pre> 
 
<p>Внимание: регистр букв важен.
Итак, основные действия:</p> 
 
<p><strong>Создание:</strong></p> 
 
<pre><code>d()-&gt;client = d()-&gt;Client-&gt;new;
d()-&gt;client-&gt;title='ainu';
d()-&gt;client-&gt;text='Суперклиент';
d()-&gt;client-&gt;save();
</code></pre> 
 
<p><strong>Редактирование:</strong></p> 
 
<pre><code>d()-&gt;client = d()-&gt;Client-&gt;find(12);
d()-&gt;client-&gt;title = "Новый заголовок";
d()-&gt;client-&gt;save();
</code></pre> 
 
<p><strong>Удаление:</strong></p> 
 
<pre><code>d()-&gt;client = d()-&gt;Client-&gt;find(12);
d()-&gt;client-&gt;delete();
</code></pre> 
 
<p>Если (например, при редактировании или создании) не было присвоено значение полю, то в
самом запросе с этим полем действий не произойдёт. На данном этапе абстракций нет,
поэтому для указания, например, автора статьи, необходимо указывать id:</p> 
 
<pre><code>$article = d()-&gt;Article-&gt;new;
$article-&gt;author_id = 21;
$article-&gt;save;
</code></pre> 
 
<p>При указании <code>-&gt;new</code> можно действовать так:</p> 
 
<pre><code>d()-&gt;client = d()-&gt;Client;
d()-&gt;client-&gt;new;
d()-&gt;client-&gt;title='Имя';
d()-&gt;client-&gt;save;
</code></pre> 
 
<p>или так:</p> 
 
<pre><code>d()-&gt;client = d()-&gt;Client;
d()-&gt;client-&gt;new-&gt;title='Имя';
d()-&gt;client-&gt;save;
</code></pre> 
 
<p>или вообще без промежуточного объекта:</p> 
 
<pre><code>d()-&gt;Client-&gt;find(7)-&gt;delete();
</code></pre> 
 
<h3>Связи</h3> 
 
<p>Все три вида связей (one-to-many, many-to-one, many-to-many) объявляются автоматически.</p> 
 
<p>TODO:</p> 
 
<pre><code>$user-&gt;posts
$post-&gt;user
</code></pre> 
</body> 
</html>
